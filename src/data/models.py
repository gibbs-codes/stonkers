"""Data models for trading system."""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional


class Direction(Enum):
    """Trade direction."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"


class SignalStrength(Enum):
    """Signal strength levels."""
    WEAK = 0.3
    MEDIUM = 0.6
    STRONG = 0.9


@dataclass
class Candle:
    """OHLCV candle data."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    pair: str = ""
    timeframe: str = ""

    @classmethod
    def from_ccxt(cls, data: list, pair: str = "", timeframe: str = ""):
        """
        Create Candle from CCXT format.

        Args:
            data: [timestamp_ms, open, high, low, close, volume]
        """
        return cls(
            timestamp=datetime.fromtimestamp(data[0] / 1000),
            open=float(data[1]),
            high=float(data[2]),
            low=float(data[3]),
            close=float(data[4]),
            volume=float(data[5]),
            pair=pair,
            timeframe=timeframe
        )

    def to_dict(self) -> dict:
        """Convert to dictionary for storage."""
        return {
            'timestamp': self.timestamp.isoformat(),
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume,
            'pair': self.pair,
            'timeframe': self.timeframe
        }


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    pair: str
    direction: Direction
    strength: float  # 0-1
    strategy_name: str
    reasoning: str
    indicators: dict = field(default_factory=dict)
    timeframe: str = ""

    def to_dict(self) -> dict:
        """Convert to dictionary for logging."""
        return {
            'timestamp': self.timestamp.isoformat(),
            'pair': self.pair,
            'direction': self.direction.value,
            'strength': self.strength,
            'strategy_name': self.strategy_name,
            'reasoning': self.reasoning,
            'indicators': self.indicators,
            'timeframe': self.timeframe
        }

    @property
    def is_actionable(self) -> bool:
        """Check if signal is strong enough to act on."""
        return self.direction != Direction.NEUTRAL and self.strength >= 0.5


@dataclass
class Position:
    """Open trading position."""
    id: str
    pair: str
    direction: Direction
    entry_price: float
    quantity: float
    entry_timestamp: datetime
    strategy_name: str
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

    def unrealized_pnl(self, current_price: float) -> float:
        """Calculate unrealized P&L."""
        if self.direction == Direction.LONG:
            pnl = (current_price - self.entry_price) * self.quantity
        else:  # SHORT
            pnl = (self.entry_price - current_price) * self.quantity
        return pnl

    def unrealized_pnl_pct(self, current_price: float) -> float:
        """Calculate unrealized P&L as percentage."""
        if self.direction == Direction.LONG:
            return ((current_price - self.entry_price) / self.entry_price) * 100
        else:  # SHORT
            return ((self.entry_price - current_price) / self.entry_price) * 100

    def to_dict(self) -> dict:
        """Convert to dictionary for storage."""
        return {
            'id': self.id,
            'pair': self.pair,
            'direction': self.direction.value,
            'entry_price': self.entry_price,
            'quantity': self.quantity,
            'entry_timestamp': self.entry_timestamp.isoformat(),
            'strategy_name': self.strategy_name,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit
        }


@dataclass
class Trade:
    """Completed trade record."""
    id: str
    timestamp: datetime
    pair: str
    direction: Direction
    entry_price: float
    exit_price: float
    quantity: float
    pnl: float
    pnl_pct: float
    strategy_name: str
    entry_timestamp: datetime
    exit_timestamp: datetime
    exit_reason: str = ""
    commission: float = 0.0

    @property
    def duration_seconds(self) -> float:
        """Trade duration in seconds."""
        return (self.exit_timestamp - self.entry_timestamp).total_seconds()

    @property
    def duration_minutes(self) -> float:
        """Trade duration in minutes."""
        return self.duration_seconds / 60

    @property
    def is_winner(self) -> bool:
        """Check if trade was profitable."""
        return self.pnl > 0

    def to_dict(self) -> dict:
        """Convert to dictionary for storage."""
        return {
            'id': self.id,
            'timestamp': self.timestamp.isoformat(),
            'pair': self.pair,
            'direction': self.direction.value,
            'entry_price': self.entry_price,
            'exit_price': self.exit_price,
            'quantity': self.quantity,
            'pnl': self.pnl,
            'pnl_pct': self.pnl_pct,
            'strategy_name': self.strategy_name,
            'entry_timestamp': self.entry_timestamp.isoformat(),
            'exit_timestamp': self.exit_timestamp.isoformat(),
            'exit_reason': self.exit_reason,
            'commission': self.commission,
            'duration_minutes': self.duration_minutes
        }
